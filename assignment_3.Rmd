---
title: "Assignment 3"
author: "Marine Courtin"
date: "17 novembre 2017"
output: html_document
---
```{r import_pipe_operator, echo=FALSE}
`%>%` <- magrittr::`%>%`
```


```{r load_func}
source("functions.R")
```


### Exercise 1: Simple data manipulation with dplyr

+ Task A.

```{r filter_table_on_dico}
stress_shift_3dict <- dplyr::filter(stressshift::stress_shift_unamb, Dict == "W1802" | Dict == "J1917" | Dict =="C1687")
print(nrow(stress_shift_3dict))
```

Logical operators :

+ or : `|`
+ and :`&`

+ Task B.

3 ways to use packages :

+ attach it by using the `library(dplyr)` command, later on we can simply use `filter` instead of `dplyr::filter`.The problem is that there is another function filter in the stats package which is attached by default. If we attach dplyr, we risk using the dplyr::filter function instead of the stats::filter function (or we could reattach stats, and forget that we need to reuse dplyr::filter afterwards). These types of problems caused by not explicity mentionning the namespace seem pretty frequent (and it makes it hard to find the source of the problem, even when we do notice a problem).
+ using the full name `dplyr::filter` every time (no risk of mixing up functions which share the same name but a different namespace. 
+ Create a shorthand for a namespace::function. This is what we did by adding the code chunk with `%>% <- magrittr::%>%`. This imports the *forward-pipe operator* from the magrittr package. What is a forward-pipe operator you may ask ? It is an operator which allows us to propagate the result of applying a function to a variable, as the argument of the next function. Adding an example with a simpler (non-R) syntax might help :

` double(4) forward-pipe triple()` -> the first operation returns 8, which in turns becomes the argument for the second function, which returns 24.


```{r first_steps_with_pipe}
stress_shift_3dict_using_pipe <- stressshift::stress_shift_unamb %>% subset(Dict == "W1802" | Dict == "J1917" | Dict =="C1687")
identical(stress_shift_3dict, stress_shift_3dict_using_pipe)
```

+ Task C.

```{r filter_and_bind_tables}
stress_shift_3dict_nouns <- stress_shift_3dict_using_pipe %>% dplyr::filter(Category=="Noun")
stress_shift_3dict_verbs <- stress_shift_3dict_using_pipe %>% dplyr::filter(Category=="Verb")
# Binding the two tables
stress_shift_3dict_using_bind <- stress_shift_3dict_nouns %>% dplyr::bind_rows(stress_shift_3dict_verbs)
# Change the order or arguments
stress_shift_3dict_using_bind_reversed <- stress_shift_3dict_verbs %>% dplyr::bind_rows(stress_shift_3dict_nouns)
# Testing if tables are identical
print(stress_shift_3dict %>% identical(stress_shift_3dict_using_bind))
print(stress_shift_3dict %>% identical(stress_shift_3dict_using_bind_reversed))
```

The differences between the two tables means that in one table rows where the Category is "Noun" will appear before rows where the Category is "Verb", while it is the opposite in the other one. Normally, if we use a function to randomize our draws from the table, this shouldn't matter. However, if we use set.seed() if think it could matter since we'll expect to get the same "random" draws every time, which we won't if we are using both tables at the same time. Therefore it would probably be best to use one of the tables consistently. 

+ Task D

```{r transform_sub_tables_join}
stress_shift_nouns_renamed <- stressshift::stress_shift_unamb %>%
  dplyr::filter(Category == "Noun") %>%
  dplyr::select(Word, Dict, Syllable) %>%
  dplyr::rename(Syllable_Noun = Syllable)
print(nrow(stress_shift_nouns_renamed))
stress_shift_verbs_renamed <- stressshift::stress_shift_unamb %>%
  dplyr::filter(Category == "Verb") %>%
  dplyr::select(Word, Dict, Syllable) %>%
  dplyr::rename(Syllable_Verb = Syllable)
print(nrow(stress_shift_verbs_renamed))
stress_shift_wide <- stress_shift_nouns_renamed %>% dplyr::inner_join(stress_shift_verbs_renamed)
```

The function dplyr::inner_join is used to find rows where the values present in table 1 and table 2 match. Whenever such as row is found, additional columns which are found only in one of the two tables are added. Here's an example :

Table 1:

Fruit | Prototypical_color | Season
------------ | -------------| -------------
Apple | red | summer
Orange | orange | spring

Table 2 :

Fruit | Size | Season
------------ | -------------| -------------
Apple | medium | autumn
Orange | medium | spring
Blueberry | small | summer

Will result in Table 3 :

Fruit | Prototypical_color | Size | Season
------------ | -------------| -------------| -------------|
Orange | orange | medium | spring

Our resulting table therefore has fewer rows because not all rows have matching values in both tables (Blueberry does not exist in table 1, Apple has contradictory values in table 1 and 2). The same applies for our stress_shift_wide table. Rows with matching values for the columns present in both tables are selected, and the columns present in only table 1 (Syllable_Noun) and in table 2 (Syllable_Verb) are added as well. This means that we are going to be able to compare stressed syllables for both noun and verb which share otherwise the same informations. 

+ Task E.


```{r plot_noun_verb_stress_distrib}
ggplot2::aes(x=Category, fill=Syllable) %>%
  ggplot2::ggplot(stressshift::stress_shift_unamb,.) +
  ggplot2::geom_bar(position="dodge", colour="black") + 
  ggplot2::scale_fill_brewer(palette="Dark2")

```

+ Task F.

```{r summarize_incomplete_table}


stress_shift_byword <- stress_shift_wide %>%
  dplyr::group_by(Word) %>%
  dplyr::summarize(Noun_Percent_Syll_1=sum(Syllable_Noun=="Syllable 1")/n(), Verb_Percent_Syll_1=sum(Syllable_Verb=="Syllable 1")/n())
print(stress_shift_byword)

if(nrow(stress_shift_byword)==149) {
      print("Il y a bien 149 lignes")
    } else {
      print("ProblÃ¨me : il n'y a pas 149 lignes")
    }
```


+ Task G.

```{r plot_incomplete_table_}
stress_shift_byword %>% 
  ggplot2::ggplot(ggplot2::aes(Noun_Percent_Syll_1, Verb_Percent_Syll_1)) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::scale_fill_brewer(palette="Dark2") +
  ggplot2::labs(title="Freq of 1st syllable stress for verbs according to same property for its noun")
```

+ Task H.

```{r summarize_full_table}
stress_shift_byword_all <- stressshift::stress_shift_unamb %>%
  dplyr::filter(Category == "Verb"|Category =="Noun") %>%
  dplyr::select(Word, Dict, Syllable, Category) %>%
  dplyr::group_by(Word) %>%
  dplyr::summarize(Noun_Percent_Syll_1=sum(Syllable=="Syllable 1" & Category=="Noun")/sum(Syllable=="Syllable 1"|Syllable=="Syllable 2" & Category=="Noun"), Verb_Percent_Syll_1=sum(Syllable=="Syllable 1" & Category=="Verb")/sum(Syllable=="Syllable 1"|Syllable=="Syllable 2" & Category=="Verb"))
print(stress_shift_byword_all)
```


### Exercise 2 : A permutation test for categorical data


+ Task A.
```{r compute_difference_in_proportion}
test_statistic <- difference_in_proportion(stressshift::stress_shift_unamb, "Syllable", "Category", "Noun", "Verb", "Syllable 1")

print(test_statistic)
```


+ Task B.

```{r}
if(!exists(".Random.seed")) set.seed(NULL)
previous_seed <- .Random.seed
set.seed(1)
ptest_stress <- permutation_twogroups(stressshift::stress_shift_unamb,"Syllable", "Category",
                                      "Noun", "Verb",difference_in_proportion,n_samples=99,"Syllable 1")
set.seed(previous_seed)
permutation_pvalue_right(ptest_stress)
print(ptest_stress)
```
