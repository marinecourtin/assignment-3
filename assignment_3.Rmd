---
title: "Assignment 3"
author: "Marine Courtin"
date: "17 novembre 2017"
output: html_document
---
```{r, echo=FALSE}
`%>%` <- magrittr::`%>%`
```


### Exercise 1: Simple data manipulation with dplyr

+ Task A.

```{r}
stress_shift_3dict <- dplyr::filter(stressshift::stress_shift_unamb, Dict == "W1802" | Dict == "J1917" | Dict =="C1687")
print(nrow(stress_shift_3dict))
```

Logical operators :

+ or : `|`
+ and :`&`

+ Task B.

3 ways to use packages :

+ attach it by using the `library(dplyr)` command, later on we can simply use `filter` instead of `dplyr::filter`.
+ using the full name `dplyr::filter` every time. For some commands this might lead to some mistakes (more details later on).
+ add a code chunk at the top of the .Rmd file with only `%>% <- magrittr::%>%`. This imports a *forward-pipe operator* from the magrittr package. What is a forward-pipe operator you may ask ? It is an operator which allows us to propagate the result of applying a function to a variable, as the argument of the next function. Adding an example without the  syntax might help :

` double(4) forward-pipe triple()` -> the first operation returns 8, which in turns becomes the argument for the second function, which returns 24.


```{r}
stress_shift_3dict_using_pipe <- stressshift::stress_shift_unamb %>% subset(Dict == "W1802" | Dict == "J1917" | Dict =="C1687")
identical(stress_shift_3dict, stress_shift_3dict_using_pipe)
```

+ Task C.

```{r}
stress_shift_3dict_nouns <- stress_shift_3dict_using_pipe %>% dplyr::filter(Category=="Noun")
stress_shift_3dict_verbs <- stress_shift_3dict_using_pipe %>% dplyr::filter(Category=="Verb")
# Binding the two tables
stress_shift_3dict_using_bind <- stress_shift_3dict_nouns %>% dplyr::bind_rows(stress_shift_3dict_verbs)
# Change the order or arguments
stress_shift_3dict_using_bind_reversed <- stress_shift_3dict_verbs %>% dplyr::bind_rows(stress_shift_3dict_nouns)
# Testing if tables are identical
print(stress_shift_3dict %>% identical(stress_shift_3dict_using_bind))
print(stress_shift_3dict %>% identical(stress_shift_3dict_using_bind_reversed))
```

The differences between the two tables means that in one table rows where the Category is "Noun" will appear before rows where the Category is "Verb", while it is the opposite in the other one. Normally, if we use a function to randomize our draws from the table, this shouldn't matter. However, if we use set.seed() if think it could matter since we'll expect to get the same "random" draws every time, which we won't if we are using both tables at the same time. Therefore it would probably be best to use one of the tables consistently. 

+ Task D

```{r}
stress_shift_nouns_renamed <- stressshift::stress_shift_unamb %>%
  dplyr::filter(Category == "Noun") %>%
  dplyr::select(Word, Dict, Syllable) %>%
  dplyr::rename(Syllable_Noun = Syllable)
print(nrow(stress_shift_nouns_renamed))
stress_shift_verbs_renamed <- stressshift::stress_shift_unamb %>%
  dplyr::filter(Category == "Verb") %>%
  dplyr::select(Word, Dict, Syllable) %>%
  dplyr::rename(Syllable_Verb = Syllable)
print(nrow(stress_shift_verbs_renamed))
stress_shift_wide <- stress_shift_nouns_renamed %>% dplyr::inner_join(stress_shift_verbs_renamed)
```

The function dplyr::inner_join is used to find rows where the values present in table 1 and table 2 match. Whenever such as row is found, additional columns which are found only in one of the two tables are added. Here's an example :

Table 1:

Fruit | Prototypical_color | Season
------------ | -------------| -------------
Apple | red | summer
Orange | orange | spring

Table 2 :

Fruit | Size | Season
------------ | -------------| -------------
Apple | medium | autumn
Orange | medium | spring
Blueberry | small | summer

Will result in Table 3 :

Fruit | Prototypical_color | Size | Season
------------ | -------------| -------------| -------------|
Orange | orange | medium | spring

Our resulting table therefore has fewer rows because not all rows have matching values in both tables (Blueberry does not exist in table 1, Apple has contradictory values in table 1 and 2). The same applies for our stress_shift_wide table. Rows with matching values for the columns present in both tables are selected, and the columns present in only table 1 (Syllable_Noun) and in table 2 (Syllable_Verb) are added as well. This means that we are going to be able to compare stressed syllables for both noun and verb which share otherwise the same informations. 

+ Task E.


```{r}
ggplot2::aes(x=Category, fill=Syllable) %>%
  ggplot2::ggplot(stressshift::stress_shift_unamb,.) +
  ggplot2::geom_bar(position="dodge", colour="black") + 
  ggplot2::scale_fill_brewer(palette="Dark2")

```

+ Task F.

```{r}


stress_shift_byword <- stress_shift_wide %>%
  dplyr::group_by(Word) %>%
  dplyr::summarize(Noun_Percent_Syll_1=sum(Syllable_Noun=="Syllable 1")/n(), Verb_Percent_Syll_1=sum(Syllable_Verb=="Syllable 1")/n())
print(stress_shift_byword)

if(nrow(stress_shift_byword)==149) {
      print("Il y a bien 149 lignes")
    } else {
      print("Problème : il n'y a pas 149 lignes")
    }
```


+ Task G.

```{r}
stress_shift_byword %>% 
  ggplot2::ggplot(ggplot2::aes(Noun_Percent_Syll_1, Verb_Percent_Syll_1)) +
  ggplot2::geom_point(alpha = 0.5) +
  ggplot2::scale_fill_brewer(palette="Dark2") +
  ggplot2::labs(title="Freq of 1st syllable stress for verbs according to same property for its noun")
```

+ Task H.

Return to your answer from Task D about why stress_shift_wide has fewer rows than either stress_shift_nouns_renamed
or stress_shift_verbs_renamed . Certain dictionary entries are missing from stress_shift_wide , as you dis-
cussed in your answer.
Starting from stressshift::stress_shift_unamb , use dplyr to create a new table called stress_shift_byword_all
with the same structure as stress_shift_byword , but which does not omit these entries. It should have 149 rows,
one word per row, a column called Noun_Percent_Syll_1 containing the proportion of entries with the stress marked
on the first syllable when the word is a noun, and a column called Verb_Percent_Syll_1 containing the proportion
of entries with the stress marked on the first syllable when the word is a verb. But the cases that were missing from
stress_shift_wide should now be included when calculating this proportion.
You should see that the value of Noun_Percent_Syll_1 for “addict”, which was given as 0.89473684 [= 17/19 ] in
the table stress_shift_byword , changes to 0.90000000 [= 18/20 ] in the new table.
